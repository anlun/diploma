\section{Реализация}

\subsection{Библиотека принтер-комбинаторов на Haskell}
К сожалению, библиотека, описанная в \cite{swierstra}, обладает экспоненциальной
сложностью относительно входного документа. В рамках данной работы удалось реализовать
принтер-комбинаторную библиотеку (см. приложение~\ref{app:1}) с тем же набором комбинаторов,
которая линейна относительно входного документа и полиномиальна
относительно максимальной ширины вывода.

% В библиотеке из \cite{swierstra} варианты раскладок хранятся в списке, в начале которого
% располагаются лучшие представления. В момент, когда построен список для всей структуры,
% результирующий
% вариант выбирается простым взятием элемента из головы списка. Фактически элементы,
% которые обладают одинаковыми размерами в терминах структуры \lstinline[language=haskell]{Format},
% неотличимы на каждом шаге
% вычислений, а среди раскладок с одинаковыми ширинами выбор падет на ту,
% что обладает меньшей высотой.
% Поэтому логично ввести факторизацию представлений по полям
% \lstinline[language=haskell]{total_w} и \lstinline[language=haskell]{last_w}
% структуры \lstinline[language=haskell]{Format}.
% Такая факторизация ограничивает количество возможных представлений на каждом этапе вычислений

\subsubsection{Применение BURS}
Сведение задачи к BURS основано на следующих наблюдениях. Пусть $w$ есть максимальная допустимая
ширина вывода. Поскольку каждая возникающая раскладка представляется структурой
\lstinline[language=Haskell]{Format}, для поиска оптимальной раскладки можно рассматривать
все промежуточные раскладки
как тройки $(n, k, h)$, где $n \le w$ --- это общая ширина раскладки, $k \le n$ ---
ширина ее последней строчки, $h$ --- ее высота. Тогда очевидно, что между $(n, k, h_1)$ и
$(n, k, h_2)$ первая тройка предпочтительней при $h_1 \le h_2$ на любом этапе вычислений.
Таким образом для каждого узла не может быть более $w^2$ существенных представлений\footnote{
На самом деле, из-за ограничения $k \le n$ максимальное число раскладок не $w^2$, a
$\frac{w^2 + w}{2}$, но это несущественно.}.

Документ, для которого мы ищем раскладку, можно рассматривать как дерево, построенное из примитивов
\lstinline[language=Haskell]{text},
\lstinline[language=Haskell]{indent},
\lstinline[language=Haskell]{beside},
\lstinline[language=Haskell]{above} и \lstinline[language=Haskell]{choice}. Тогда задачу
раскладки документа можно решать независимо для поддеревьев, а потом объединять решения
при учете, что для каждого поддерева
и каждой пары $(n, k), k \le n \le w$ запоминается минимальная такая $h$, что для поддерева существует
текстовое представление с размерами $(n, k, h)$. Тогда, совершив обход дерева снизу вверх, мы сможем
вычислить оптимальное представление для всего дерева. Полезно заметить,
что оптимальное представление дерева не всегда получается из оптимальных представлений его
поддеревьев.

Эти наблюдения можно формализовать в виде BURS-задачи.
Для заданной ширины вывода $w$ введем набор нетерминалов
$T_n^k$, для всех $k \le n \le w$. Определим BURS грамматику так, чтобы цена вывода $h$ нетерминала
$T_n^k$ для документа соответствовала его раскладке с параметрами $(n, k, h)$.
Для такой BURS грамматики этап разметки посчитает все полезные раскладки, а этап свертки
вернет оптимальную. Определим правила переписывания для этой грамматики:
\begin{enumerate}
\item Для терминального узла $[\mbox{\lstinline{text s}}]$\footnote{
  Квадратные скобки используются для обозначения терминалов, состоящих из нескольких символов.}
  существует два варианта:
  \begin{itemize}
     \item Если $|s|\le w$ (где $|s|$ --- это длина строки $s$), то вводится единственное правило
           $T^{|s|}_{|s|}: [\mbox{\lstinline{text s}}]$ с ценой $1$;
           
           для всех остальных
           $k, n\ne |s|$ используется $T^k_n:[\mbox{\lstinline{text s}}]$ с ценой $\infty$;
     \item Если $|s| > w$, то используется $T^k_n:[\mbox{\lstinline{text s}}]$ с ценой\
       $\infty$ для всех $k, n$.
  \end{itemize}
  Действительно, раскладка документа, состоящего из строчки длины $|s|$, может быть только размеров
  $(|s|, |s|, 1)$. Все остальные размеры недоступны, поэтому имеют цену $\infty$.

\item Для узла $[\mbox{\lstinline{indent m}}]$ введем два набора правил:
  \begin{enumerate}
     \item $T^{k+m}_{n+m}:[\mbox{\lstinline{indent m}}]\:(T^k_n)$ с ценой,
       равной цене раскладки поддерева $m$ в $T_n^k$ , для всех $n$ 
     и $k$ таких, что $n+m\le w$ и $k\le n$;
     \item $T^k_n:[\mbox{\lstinline{indent m}}]\:(T^i_j)$ с ценой $\infty$ в противном случае.
  \end{enumerate}
  Понятно, что сдвиг раскладки с параметрами $n$, $k$ и $h$ на $m$ позиций вправо
  создает раскладку с параметрами $n+m$, $k+m$, $h$. Такая раскладка допустима, если
  $n+m\le w$ и $k+m\le w$.

\item Для узла $[\mbox{\lstinline{above}}]$ вводим правило $T^{k_2}_{\max(n_1, n_2)}:[\mbox{\lstinline{above}}]\:(T^{k_1}_{n_1},\;T^{k_2}_{n_2})$ 
с ценой, равной сумме цен вывода поддеревьев, для всех $k_1\le n_1\le w$ и $k_2 \le n_2 \le w$.

Действительно, при вертикальном соединении раскладок с параметрами
$n_1$, $k_1$, $h_1$ и $n_2$, $k_2$, $h_2$ мы получаем раскладку с размерами
$\max\:(n_1,n_2)$, $k_2$, $h_1+h_2$. Вертикальная композиция допустимых раскладок всегда допустима.

\item Для узла $[\mbox{\lstinline{beside}}]$ вводим правило
  $T^{k_1+k_2}_{\max\:(n_1,\:k_1+n_2)}:[\mbox{\lstinline{beside}}]\:(T^{k_1}_{n_1},\:T^{k_2}_{n_2})$
  для каждой комбинации $n_1, n_2, k_1, k_2$ такой, что $k_1+k_2\le\max\:(n_1,\:k_1+n_2)\le w$.
  Цена такого вывода равна сумме цен вывод поддеревьев минус 1.
  Может быть легко проверена геометрическими соображениями.

\item Для узла $[\mbox{\lstinline{choice}}]$ вводим правило
  $T^k_n:[\mbox{\lstinline{choice}}]\:(T^k_n,\:T^k_n)$ для всех $k\le n\le w$.

  Цена есть минимум среди цен вывода для поддеревьев. Понятно, что среди двух раскладок
  с одинаковыми ширинами выбирается та, что имеет меньшую высоту.
\end{enumerate}


\subsection{Библиотека принтер-комбинаторов на Kotlin}
Дополнительный комбинатор Fill

\subsection{Принтер-плагин Java для IntelliJ IDEA}

Все хорошо, но есть проблемы.

