\section{Реализация}

\subsection{Библиотека принтер-комбинаторов на Haskell}
К сожалению, библиотека, описанная в \cite{swierstra}, обладает экспоненциальной
сложностью относительно входного документа. В рамках данной работы удалось реализовать
принтер-комбинаторную библиотеку (см. приложение~\ref{app:1}) с тем же набором комбинаторов,
которая линейна относительно входного документа и полиномиальна
относительно максимальной ширины вывода.

% В библиотеке из \cite{swierstra} варианты раскладок хранятся в списке, в начале которого
% располагаются лучшие представления. В момент, когда построен список для всей структуры,
% результирующий
% вариант выбирается простым взятием элемента из головы списка. Фактически элементы,
% которые обладают одинаковыми размерами в терминах структуры \lstinline[language=haskell]{Format},
% неотличимы на каждом шаге
% вычислений, а среди раскладок с одинаковыми ширинами выбор падет на ту,
% что обладает меньшей высотой.
% Поэтому логично ввести факторизацию представлений по полям
% \lstinline[language=haskell]{total_w} и \lstinline[language=haskell]{last_w}
% структуры \lstinline[language=haskell]{Format}.
% Такая факторизация ограничивает количество возможных представлений на каждом этапе вычислений

\input{bursReduction}

\subsubsection{Мемоизация вычислений для поддеревьев}

В реальных принтерах документы, состоящие из комбинаторов
\lstinline[language=Haskell]{text},
\lstinline[language=Haskell]{indent},
\lstinline[language=Haskell]{beside},
\lstinline[language=Haskell]{above} и \lstinline[language=Haskell]{choice}, чаще всего
представляют собой не дерево, а \textit{дэг} (DAG, Direct Acyclic Graph). Поэтому при наивной
реализации BURS можно получить экспоненциальную сложность от размеров документа,
поскольку соответствующее дерево будет иметь экспоненциальный размер от размера дэга.
Чтобы избежать этой проблемы достаточно завести HashMap, который будет хранить соответствие
поддерева с посчитанным для него набором раскладок. Опять же в наивной реализации,
это сделает алгоритм квадратичным от размера дэга, так как вычисления хэша для дерева занимает
линейное время. Чтобы преодолеть и эту сложность, надо в дереве хранить вычисленный хэш.
К сожалению, это сложно выразить на Haskell, поэтому эта оптимизация оставлена только для реализации
на Kotlin.

\subsection{Библиотека принтер-комбинаторов на Kotlin}
Дополнительный комбинатор Fill

\subsection{Принтер-плагин Java для IntelliJ IDEA}

Все хорошо, но есть проблемы.

