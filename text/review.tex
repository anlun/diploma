\section{Обзор}

\subsection{Принтер-комбинаторы}

Большинство принтер-комбинаторных библиотек\cite{
swierstraChitil, swierstra04, peytonJones, kiselyov, chitil, swiComb}
являются развитиями библиотек
Джона Хьюза\cite{hughes} и Филиппа Вадлера\cite{wadler}, которые,
в свою очередь, представляют собой функциональную реализацию алгоритма
Оппена\cite{oppen}.
% Ограничимся рассмотрением библиотеки Вадлера, так как
% библиотека Хьюза и остальные приведенные выше не отличаются принципиально
% в рамках данного рассуждения.
Для конкретики будем говорить о библиотеке Вадлера, но основные выводы
также верны для всех упомянутых выше принтер-комбинаторных библиотек.

В библиотеке ключевым типом является тип документа.
Он представляет сущность, которая потом может
быть переведена в строковое представление алгоритмом принтера.
Основные конструкторы для составления документа:
\begin{itemize}
  \item атомарная строка, которая печатается как есть;
  \item \emph{разделитель};
  \item последовательная композиция двух документов;
  \item набор связанных документов.
\end{itemize}

Определяющей особенностью данного подхода является то, что все разделители
в рамках одного набора могут быть совместно заменены алгоритмом принтера
на пробельный символ или на перевод строки. Выбор для каждого набора разделителей
основывается на том, что вывод должен поместиться в заданную ширину,
используя минимальное число строк.

Основная проблема такого подхода заключается в его слабой выразительной силе.
Документы, построенные по синтаксическому дереву печатываемой программы,
обрабатываются слишком единообразно, что иногда приводит к нежелательному результату.
Пусть, к примеру, нужно напечатать программу на языке Python\footnote{http://python.org}.
Между последовательными операторами, в случае их печати на одной строчке, необходимо
добавить дополнительный разделитель (``;''), иначе программа станет некорректной
(см. рис.~\ref{fig:seqEx}). Однако, описанные принтер-комбинаторы не предоставляют
возможности задать такое поведение.
Кроме того, с помощью таких принтер-комбинаторов невозможно выразить разные проектные СК,
так как они всегда печатают текст в одном стиле, который жестко зашит в их код.

\begin{figure}[h!]
	\centering
	\null\hfill
	\subfloat[Корректный код]{
		\centering
    \makebox[.4\textwidth] {
		  \lstinputlisting[language=Python]{codes/pythonCode.py}
    }
	}
	\null\hfill
	\subfloat[Некорректный код]{
		\centering
    \makebox[.4\textwidth] {
	  	\lstinputlisting[language=Python]{codes/pythonCodeBad.py}
    }
	}
	\hfill\null
	\caption{Пример работы принтер-комбинаторов для языка Python}
  \label{fig:seqEx}	
\end{figure}


% Рассмотрим их на примере библиотеки Вадлера. В этой библиотеке ключевым типом является
% ``\lstinline[language=Haskell]{Doc}''. Он представляет документ, который потом может
% быть переведен в строковое представление. Основные комбинаторы для составления документа:

% \lstinputlisting[language=Haskell]{codes/wadlerBasicOperations.hs}

% Так, с помощью функции ``\lstinline[language=Haskell]{text}'' по строчке получается
% простой документ, представляющий это строчку.
% ``\lstinline[language=Haskell]{<>}''.

Более подробный обзор библиотек Хьюза и Вадлера есть в предыдущей работе\cite{myCoursePaper}.

\subsection{Принтер-комбинаторы с выбором}
Достаточная выразительная сила, но существующая реализация экспоненциальна
относительно размеров входа.

\subsubsection{Структура Format}

\subsection{Средства форматирования кода в IDE}

\subsubsection{IDEA}
adas
\subsubsection{Eclipse}
sdasd

\input{burs}

\subsection{Язык программирования Kotlin}

Язык Kotlin это функциональный, объектно-ориентированный язык,
разрабатываемый в компании JetBrains.
Kotlin был выбран для реализации принтер-плагина к IDEA по нескольким причинам. 
Во-первых, Kotlin обладает хорошей интеграцией с Java, что позволяет
использовать его без проблем с IDEA API. 
Во-вторых, функции в Kotlin являются объектами первого рода, что позволяет
легко реализовывать комбинаторные библиотеки на нем.
На данный момент Kotlin находится в стадии разработки, поэтому
периодически возникают
проблемы с тем, что исходные коды перестают быть совместимыми с новыми
версиями языка,
но обычно требуется внести небольшой набор исправлений для
восстановления работоспособности.
