\section{Реализация}

\subsection{Библиотека принтер-комбинаторов на Haskell}
К сожалению, библиотека, описанная в \cite{swierstra}, обладает экспоненциальной
сложностью относительно входного документа. В рамках данной работы удалось реализовать
принтер-комбинаторную библиотеку (см. приложение~\ref{app:1}) с тем же набором комбинаторов,
которая линейна относительно входного документа и полиномиальна
относительно максимальной ширины вывода.

% В библиотеке из \cite{swierstra} варианты раскладок хранятся в списке, в начале которого
% располагаются лучшие представления. В момент, когда построен список для всей структуры,
% результирующий
% вариант выбирается простым взятием элемента из головы списка. Фактически элементы,
% которые обладают одинаковыми размерами в терминах структуры \lstinline[language=haskell]{Format},
% неотличимы на каждом шаге
% вычислений, а среди раскладок с одинаковыми ширинами выбор падет на ту,
% что обладает меньшей высотой.
% Поэтому логично ввести факторизацию представлений по полям
% \lstinline[language=haskell]{total_w} и \lstinline[language=haskell]{last_w}
% структуры \lstinline[language=haskell]{Format}.
% Такая факторизация ограничивает количество возможных представлений на каждом этапе вычислений

\input{bursReduction}

\subsubsection{Мемоизация вычислений для поддеревьев}

В реальных принтерах документы, состоящие из комбинаторов
\lstinline[language=Haskell]{text},
\lstinline[language=Haskell]{indent},
\lstinline[language=Haskell]{beside},
\lstinline[language=Haskell]{above} и \lstinline[language=Haskell]{choice}, чаще всего
представляют собой не дерево, а \textit{дэг} (DAG, Direct Acyclic Graph). Поэтому при наивной
реализации BURS можно получить экспоненциальную сложность от размеров документа,
поскольку соответствующее дерево будет иметь экспоненциальный размер от размера дэга.
Чтобы избежать этой проблемы достаточно завести HashMap, который будет хранить соответствие
поддерева с посчитанным для него набором раскладок. Опять же в наивной реализации,
это сделает алгоритм квадратичным от размера дэга, так как вычисления хэша для дерева занимает
линейное время. Чтобы преодолеть и эту сложность, надо в дереве хранить вычисленный хэш.
К сожалению, это сложно выразить на Haskell, поэтому эта оптимизация оставлена только для реализации
на Kotlin.

\subsection{Библиотека принтер-комбинаторов на Kotlin}

\subsubsection{Комбинатор Fill}

Для реализации принтера, использующего шаблоны, необходимо добавить
дополнительный принтер-комбинатор в бибилиотеку --- комбинатор Fill.

\begin{figure}[h!]
  \centering
	\subfloat[]{
		\centering
    \tikz[scale = 2.5]{
       \draw (0,0) -- (1,0) -- (1,0.2) -- (2,0.2) -- (2,1) --
          (0, 1) -- cycle;
       \draw (0,-0.1) -- (0,-1.1) -- (1.1,-1.1) -- (1.1,-0.9) --
          (2.3,-0.9) -- (2.3, 0.1) -- (1.1,0.1) -- (1.1,-0.1) -- cycle;
    }
		\label{fig:fill1}
	}
	\quad
  \subfloat[][fc --- константа сдвига]{
		\centering
    \tikz[scale = 2.5]{
          \draw (0,0) -- (1,0) -- (1,0.2) -- (2,0.2) -- (2,1)
            -- (0, 1) -- cycle;
          \draw (0.3,-0.1) -- (0.3,-1.1) -- (1.1,-1.1) -- (1.1,-0.9)
            -- (2.3,-0.9) -- (2.3, 0.1) -- (1.1,0.1) -- (1.1,-0.1) -- cycle;
          \draw[<->] (0,-0.6) -- (0.3,-0.6);
          \draw (0.15,-0.4) node [fill=white] {\tiny fc};
          \draw[dashed] (0,0) -- (0,-1.1);
       }
		\label{fig:fill2}
	}
	\caption{Оператор Fill}
\end{figure}

TODO: Примеры, зачем нужно. К примеру, PsiCodeBlock

К сожалению, теперь становится недостаточно факторизовать структуры Format
только по общей ширине и ширине последней строчки.
С комбинатором Fill фактор-пространство дополнительно параметризуется и первой
строчкой.

TODO: привести примеры

\subsubsection{Дополнительная фильтрация вариантов}

Для того, чтобы избежать экспоненциальной сложности вычисления оптимальной
раскладки документа, мы ввели факторизацию по размерам (ширинам).
Количество раскладок для каждого поддерева теперь ограничено, но, к сожалению,
слишком большой константой --- $O(w^3)$ ($O(w^2)$ для набора комбинаторов без
Fill), а сложность вычисления узлов Beside, Above, Fill --- $O(w^6)$
($O(w^4)$ без комбинатора Fill). Факторизация была основана на том факте, что
среди раскладок с одинаковыми ширинами в любом дальнейшем использовании
оптимальнее вариант с меньшей высотой. Для дополнительной фильтрации множества
вариантов воспользуемся рассуждением, что если раскладка $A$ обладает и
меньшими ширинами, и меньшей высотой, чем раскладка $B$, то, как и раньше,
достаточно оставить только ее во множестве вариантов.

Таким образом мы ввели отношение частичного порядка на раскладках, а
описанная фильтрация --- поиск минимумов на множестве представлений\cite{poset}.
Наивная реализация поиска имеет квадратичную сложность от размера множества,
таким образом асимптотика алгоритма не ухудшается из-за этих дополнительных
действий. К сожалению, данная оптимизация и не улучшает поведение
в худшем случае, так как
можно привести пример, когда все множество раскладок с допустимыми ширинами
будет состоять из несравнимых элементов, но на практике количество вариантов
существенно сокращается, что делает весь подход применимым на реальных данных.

\subsection{Принтер-плагин Java для IntelliJ IDEA}

TODO

Стоит заметить, что с инженерной точки зрения для решения отдельно стоящей задачи
форматирования по образцу кода на Java в IntelliJ IDEA лучше подходит
получение настроек для существующего форматтера с помощью известных техник обучения.
Подобный подход используется в работе \cite{learning}.
Но наш метод позволяет выразить представления, которые не предусмотрены
встроенным форматтером, кроме того потенциально предоставляет возможность проще
создавать форматтеры для новых языков. 

\subsubsection{Получение шаблонов}
Тут надо написать, как же таки получаются шаблоны.

Получаются из эталонного репозитория.

\subsubsection{Производительность}

Для оценки производительности были рассмотрены самые большие исходные файлы
проекта IntelliJ IDEA Community Edition\footnote{
IntelliJ IDEA Community Edition,
http://github.com/jetbrains/intellij-community/}.
Результаты производительности приведены в
таблице~\ref{tbl:pluginPerformanceTbl}.

\begin{table}
	\centering

  \subfloat[Ширина 200] {
    \centering
    \begin{tabular}{c c c}
    Имя файла & Количество строк & Время \\
    \hline
    Messages.java & 2007 & 1.76 \\
    UIUtil.java & 2808 & 1.56 \\
    AbstractTreeUi.java & 5112 & 2.25 \\
    EditorImpl.java & 6789 & 2.74 \\
    ConcurrentHashMap.java & 7191 & 2.05 
    \end{tabular}
  }

  \subfloat[Ширина 250] {
    \centering
    \begin{tabular}{c c c}
    Имя файла & Количество строк & Время \\
    \hline
    Messages.java & 2007 & 1.01 \\
    UIUtil.java & 2808 & 1.58 \\
    AbstractTreeUi.java & 5112 & 2.68 \\
    EditorImpl.java & 6789 & 2.93 \\
    ConcurrentHashMap.java & 7191 & 2.03 \\
    \end{tabular}
  }

	\caption{Время форматирования файлов (в секундах)}
	\label{tbl:pluginPerformanceTbl}
\end{table}

\subsubsection{Открытые проблемы}

К сожалению, есть несколько принципиально нерешенных проблем. Первой такой
проблемой является печать синтаксических структур с переменным числом
подвыражений. К примеру, это списки и бинарные выражения. Проблема вызвана
тем, что непонятно, как для таких структур задавать шаблоны. Можно хранить
представления для списков по количеству элементов
до некоторой максимальной длины, но,
во-первых, это достаточно обременительно, учитывая количество разнообразных
типов списков, а, во-вторых, такой подход не сможет работать на списках большей
длины. В рамках данной работы было реализовано два разных решения для данной
задачи --- классический для форматтеров из IDE и с использованием шаблона для
пары элементов списка.

Классический способ решения проблемы для списков заключается в том, что
списки просто печатаются заполняющим методом (см. пример на
рисунке~\ref{fig:listClassicEx}).

\begin{figure}[h!]
  \textbf{Тут надо привести какой-нибудь пример}

  \label{fig:listClassicEx}
  \caption{Пример классической печати списков}
\end{figure}


Второй проблемой является задание порядка поддеревьев для конструкций, которые
его явным образом не определяют. К примеру, это верно для классов в Java.
