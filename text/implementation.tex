\section{Реализация}

\input{bursReduction}

\newpage
\subsection{Библиотека принтер-комбинаторов на Haskell}

В рамках данной работы удалось реализовать
принтер-комбинаторную библиотеку (см. приложение~\ref{app:1}) с тем же набором комбинаторов,
что и в~\cite{swierstra},
которая линейна относительно входного документа и полиномиальна
относительно максимальной ширины вывода, за счет описанного выше сведения задачи к BURS.
Данная реализация использует низкоуровневые типы и функции из оригинальной
библиотеки~\cite{swierstra}, в то время как высокоуровневые типы и комбинаторы переопределены.

В реализации нет непосредственного использования BURS: в явном виде не задается BURS-грамматика,
нет набора нетерминалов и стандартного алгоритма обработки.
Вместо этого для каждого узла документа вычисляется ассоциативный массив, который
ставит в соответствие паре $(n, k)$ лучший (минимальный по числу строк) Format с параметрами
ширин $n$ и $k$. Так, в ассоциативном массиве записаны пары $((n, k), f)$, где $f$ --- это
блок Format, соответствующий оптимальному представлению с ширинами $(n, k)$. Значение
высоты $f$ есть минимальная стоимость вывода нетерминала $T^k_n$ для данного узла.
Заметим, что поскольку $f$ является конечным результатом для $T^k_n$, а не просто
последним правилом, которое нужно применить для построения ответа, то отменяется
необходимость применения в дальнейшем алгоритма свертки.
В конце, для корня дерева, представляющего документ, выбирается элемент минимальной стоимости из
ассоциативного массива.

Наибольший интерес в рамках данного исследования представляет поведение библиотеки
в худшем случае.
Реализация была апробирована для бинарных деревьев.
Функция генерации деревьев приведена на рисунке~\ref{fig:treeToDocMy}.
Здесь используются операторы
\lstinline[language= Haskell]{(>|<)},
\lstinline[language= Haskell]{(>-<)},
\lstinline[language= Haskell]{(>//<)}, которые являются инфиксными синоминами для
комбинаторов
\lstinline[language= Haskell]{beside},
\lstinline[language= Haskell]{above} и
\lstinline[language= Haskell]{choice} соответственно.

\begin{figure}[h!]
  \lstinputlisting[language = Haskell]{codes/AltPrettyTest.hs}
  \caption{Функция генерации деревьев для тестов производительности}
  \label{fig:treeToDocMy}
\end{figure}

Результаты времени исполнения для сравнения авторской реализации с оригинальной библиотекой
приведены в таблице~\ref{tbl:time}.
Из приведенных данных видно, что, начиная с некоторой комбинации ширины вывода и размера документа,
библиотека~\cite{swierstra} не может вычислить раскладку документа.
Значения, записанные подобно \mbox{``-($>$ 59)''},
указывают, что после указанного времени процесс аварийно завершился с переполнением стека.

Авторская реализация часто не показывает линейное поведение, как это ожидается при фактическом
учетверении числа узлов в документе от строчки к строчке. Дополнительные эксперименты показали
связь данного поведения с разреженностью ассоциативного массива для больших ширин.
Другими словами, для маленьких деревьев число значений в соответствующем ассоциативном массиве
сильно меньше верхней границы. С ростом размера дерева число записей растет быстрее чем
с линейной скоростью, пока не будут достигнуты значения, близкие к верхней границе.

Кроме того, особенностью описанной реализации является то, что она не использует 
ленивые вычисления для ускорения построения оптимального текстового представления для
поданного на вход документа, а, наоборот,
форсирует большинство вычислений, что делает ее легко портируемой на языки
без встроенной ленивости.

Полные исходные коды библиотеки вместе с тестами можно найти на

\cd{http://github.com/anlun/polynomialPPCombinators}.

\input{haskellTbl}

\newpage
\subsection{Библиотека принтер-комбинаторов на Kotlin}

\subsubsection{Мемоизация вычислений для поддеревьев}

В реальных принтерах документы, состоящие из комбинаторов
\lstinline[language=Haskell]{text},
\lstinline[language=Haskell]{indent},
\lstinline[language=Haskell]{beside},
\lstinline[language=Haskell]{above} и \lstinline[language=Haskell]{choice}, чаще всего
представляют собой не дерево, а \textit{дэг} (DAG, Direct Acyclic Graph). Поэтому при наивной
реализации можно получить экспоненциальную сложность от размеров документа,
поскольку соответствующее дерево будет иметь экспоненциальный размер от размера дэга.
Чтобы избежать этой проблемы достаточно завести ассоциативный массив,
который будет хранить посчитанный набор раскладок по конкретному поддереву.
Опять же при наивной реализации данной оптимизации,
алгоритм вычисления раскладки становится квадратичным от размера дэга,
так как вычисление хэша, используемого ассоциативным массивом, для дерева занимает
линейное время. Чтобы преодолеть и эту сложность, в дереве хранится вычисленный хэш.

\subsubsection{Комбинатор Fill}

Для реализации принтера, использующего шаблоны, необходимо добавить
дополнительный принтер-комбинатор в библиотеку --- комбинатор Fill.

\begin{figure}[h!]
  \centering
	\subfloat[]{
		\centering
    \tikz[scale = 2.5]{
       \draw (0,0) -- (1,0) -- (1,0.2) -- (2,0.2) -- (2,1) --
          (0, 1) -- cycle;
       \draw (0,-0.1) -- (0,-1.1) -- (1.1,-1.1) -- (1.1,-0.9) --
          (2.3,-0.9) -- (2.3, 0.1) -- (1.1,0.1) -- (1.1,-0.1) -- cycle;
    }
		\label{fig:fill1}
	}
	\quad
  \subfloat[][fc --- константа сдвига]{
		\centering
    \tikz[scale = 2.5]{
          \draw (0,0) -- (1,0) -- (1,0.2) -- (2,0.2) -- (2,1)
            -- (0, 1) -- cycle;
          \draw (0.3,-0.1) -- (0.3,-1.1) -- (1.1,-1.1) -- (1.1,-0.9)
            -- (2.3,-0.9) -- (2.3, 0.1) -- (1.1,0.1) -- (1.1,-0.1) -- cycle;
          \draw[<->] (0,-0.6) -- (0.3,-0.6);
          \draw (0.15,-0.4) node [fill=white] {\tiny fc};
          \draw[dashed] (0,0) -- (0,-1.1);
       }
		\label{fig:fill2}
	}
	\caption{Оператор Fill}
\end{figure}

В качестве примера, показывающего полезность такого комбинатора, рассмотрим
печать метода из языка Java. Пусть нам нужно получить на выходе следующий программный
код:

\lstinputlisting[language = Java]{codes/codeBlockEx.java}

По описанному раннее подходу, для построения общей раскладки необходимо иметь представления
поддеревьев. В частности, представление тела метода:

\lstinputlisting[language = Java]{codes/justBlockEx.java}

Тогда для реализации необходимого соединения, представленного ниже, необходим комбинатор Fill:

\lstinputlisting[language = Java]{codes/codeBlockTemplateEx.java}

К сожалению, введение нового комбинатора накладывает дополнительные ограничения на
факторизацию. Это связано с тем, что теперь по парам $(n, k)$, где $n$ --- общая ширина,
а $k$ --- ширина последней строчки, нельзя однозначным образом выдать соответствующую
пару для раскладки соединения двух блоков. Так, при применении Fill комбинатора
важной становиться и ширина первой строчки нижнего блока, поскольку сумма ее и ширины
последней строчки верхнего блока могут дать максимум общей ширины. Таким образом,
у нетерминалов из BURS-сведения появляется дополнительный индекс, а из число
увеличивается с $w^2$ до $w^3$. Аналогично, количество правил перехода возрастает
с $O(w^4)$ до $O(w^6)$.

\subsubsection{Дополнительная фильтрация вариантов}

Для того, чтобы избежать экспоненциальной сложности вычисления оптимальной
раскладки документа, мы ввели факторизацию по размерам (ширинам).
Количество раскладок для каждого поддерева теперь ограничено, но, к сожалению,
слишком большой константой --- $w^3$ ($w^2$ для набора комбинаторов без
Fill), а сложность вычисления узлов Beside, Above, Fill --- $O(w^6)$
($O(w^4)$ без комбинатора Fill). Факторизация была основана на том факте, что
среди раскладок с одинаковыми ширинами в любом дальнейшем использовании
к лучшему результату приводит вариант с меньшей высотой.
Для дополнительной фильтрации множества
вариантов воспользуемся рассуждением, что если раскладка $A$ обладает и
меньшими ширинами, и меньшей высотой, чем раскладка $B$, то, как и раньше,
достаточно оставить только ее во множестве вариантов.

Таким образом мы ввели отношение частичного порядка на раскладках, а
описанная фильтрация --- поиск минимумов на множестве представлений\cite{poset}.
Наивная реализация поиска имеет квадратичную сложность от размера множества,
таким образом асимптотика алгоритма не ухудшается из-за этих дополнительных
действий. К сожалению, данная оптимизация и не улучшает поведение
в худшем случае, так как
можно привести пример, когда все множество раскладок с допустимыми ширинами
будет состоять из несравнимых элементов, но на практике количество вариантов
существенно сокращается, что делает весь подход применимым на реальных данных.

\newpage
\subsection{Принтер-плагин Java для IntelliJ IDEA}

TODO: в целом еще раз осветить подход, подробнее.

Стоит заметить, что с инженерной точки зрения для решения отдельно стоящей задачи
форматирования по образцу кода на Java в IntelliJ IDEA лучше подходит
получение настроек для существующего форматтера с помощью известных техник обучения.
Подобный подход используется в работе \cite{learning}.
Но наш метод позволяет выразить представления, которые не предусмотрены
встроенным форматтером, кроме того потенциально предоставляет возможность проще
создавать форматтеры для новых языков. 

Описание BURS подхода на уровне шаблонов.

\subsubsection{Получение и применение шаблонов}
Для применения описанного подхода необходимо иметь набор шаблонов. Для большей
конкретики уточним данное понятие. Под \emph{шаблоном} в данном контексте мы будем
понимать данные, которые по представлениям поддеревьев позволяют построить
раскладку для объемлющего узла. Фактически в реализации это размеченное дерево разбора
некоторой синтаксической конструкции, в котором по каждой метке можно выяснить
ограничения на представление соответствующих поддеревьев и описание, каким
образом нужная раскладка поддерева должна быть вставлена в шаблон (Beside, Fill).

Для получения шаблонов плагин проходит по переданному пользователем репозиторию с
эталонным исходным кодом. По каждому узлу деревьев разбора файлов из репозитория
строится шаблон соответствующей синтаксической конструкции. Важной особенностью
является то, что для дальнейшей печати конструкций, имеющих плавающие число
поддеревьев, необходимо иметь отдельный шаблон для каждой комбинации
присутствия поддеревьев.
Это серьезное ограничение, но его невозможно обойти в рамках данного подхода.

Поскольку каждый узел дерева разбора из эталонного репозитория порождает
шаблон, то частой ситуацией является присутствие шаблонов, которые функционально
неотличимы. Их наличие ухудшает время работы принтера, так как повторяются
аналогичные переходы от представлений поддеревьев печатаемого узла, приводящие
к одному и тому же результату. Чтобы избежать данной проблемы достаточно ввести
факторизацию по функциональному поведению на множестве шаблонов. На практике это
было реализовано в виде факторизации по текстовому представлению шаблона,
в котором на месте меток записана информация об ограничении на раскладки
соответствующих поддеревьев.

Несколько полярной проблемой являются шаблоны, получаемые из уникальных,
завязанных на контекст ситуаций. Так рассмотрим шаблоны для поля класса Java,
получаемые из следующего текста:

\lstinputlisting[language = Java]{codes/fieldsT1.java}

Здесь на выходе получается один и тот же факторизованный шаблон.
Несколько изменим пример. Пусть теперь
в эталонном коде было сделано дополнительное выравнивание по типам
и модификаторам доступа:

\lstinputlisting[language = Java]{codes/fieldsT2.java}

По такому эталону получается три разных шаблона, каждый из которых не может
быть использован в произвольном случае. Кроме того, так как подход в целом не
умеет представлять поддеревья в зависимости от контекста, то полученные шаблоны
бесполезны и вредны. Поэтому для борьбы с подобными ситуациями имеет смысл
предпочитать то представление, что было получено из факторизованного шаблона с
наибольшим \emph{весом}, где под весом понимается встречаемость шаблона в
эталонном тексте.

\subsubsection{Анализ производительности}

Для оценки производительности были рассмотрены самые большие исходные файлы
проекта IntelliJ IDEA Community Edition\footnote{
IntelliJ IDEA Community Edition,
http://github.com/jetbrains/intellij-community/}.
Результаты производительности приведены в
таблице~\ref{tbl:pluginPerformanceTbl}.

\begin{table}[h!]
	\centering

  \subfloat[Ширина 200] {
    \centering
    \begin{tabular}{c c c}
    Имя файла & Количество строк & Время \\
    \hline
    Messages.java & 2007 & 1.76 \\
    UIUtil.java & 2808 & 1.56 \\
    AbstractTreeUi.java & 5112 & 2.25 \\
    EditorImpl.java & 6789 & 2.74 \\
    ConcurrentHashMap.java & 7191 & 2.05 
    \end{tabular}
  }

  \subfloat[Ширина 250] {
    \centering
    \begin{tabular}{c c c}
    Имя файла & Количество строк & Время \\
    \hline
    Messages.java & 2007 & 1.01 \\
    UIUtil.java & 2808 & 1.58 \\
    AbstractTreeUi.java & 5112 & 2.68 \\
    EditorImpl.java & 6789 & 2.93 \\
    ConcurrentHashMap.java & 7191 & 2.03 \\
    \end{tabular}
  }

	\caption{Время форматирования файлов (в секундах)}
	\label{tbl:pluginPerformanceTbl}
\end{table}

\subsubsection{Открытые проблемы}

К сожалению, есть несколько принципиально нерешенных проблем. Первой такой
проблемой является печать синтаксических структур с переменным числом
подвыражений. К примеру, это списки и бинарные выражения. Проблема вызвана
тем, что непонятно, как для таких структур задавать шаблоны. Можно хранить
представления для списков по количеству элементов
до некоторой максимальной длины, но,
во-первых, это достаточно обременительно, учитывая количество разнообразных
типов списков, а, во-вторых, такой подход не сможет работать на списках большей
длины. В рамках данной работы было реализовано два разных решения для данной
задачи --- классический для форматтеров из IDE и с использованием шаблона для
пары элементов списка.

Классический способ решения проблемы для списков заключается в том, что
списки просто печатаются заполняющим методом (см. пример на
рисунке~\ref{fig:listClassicEx}).

\begin{figure}[h!]
  \textbf{Тут надо привести какой-нибудь пример}

  \caption{Пример классической печати списков}
  \label{fig:listClassicEx}
\end{figure}


Второй проблемой является задание порядка поддеревьев для конструкций, которые
его явным образом не определяют. К примеру, это верно для классов в Java.
